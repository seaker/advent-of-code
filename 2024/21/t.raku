#!/bin/env raku

unit sub MAIN(Str:D $f where *.IO.f = 'input.txt');

my %np2dp =
    0 => (0 => 'A', 1 => '^<A', 2 => '^A', 3 => ['^>A', '>^A'], 4 => ['^^<A', '^<^A'], 5 => '^^A', 6 => ['^^>A', '^>^A', '>^^A'], 7 => ['^^^<A', '^^<^A', '^<^^A'], 8 => '^^^A', 9 => ['^^^>A', '^^>^A', '^>^^A', '>^^^A'], A => '>A').Hash,
    1 => (0 => '>vA', 1 => 'A', 2 => '>A', 3 => '>>A', 4 => '^A', 5 => ['^>A', '>^A'], 6 => ['>>^A', '^>>A', '>^>A'], 7 => '^^A', 8 => ['^^>A', '^>^A', '>^^A'], 9 => ['^^>>A', '^>^>A', '>^^>A', '>>^^A', '^>>^A', '>^>^A'], A => ['>v>A', '>>vA']).Hash,
    2 => (0 => 'vA', 1 => '<A', 2 => 'A', 3 => '>A', 4 => ['^<A', '<^A'], 5 => '^A', 6 => ['^>A', '>^A'], 7 => ['^^<A', '^<^A', '<^^A'], 8 => '^^A', 9 => ['^^>A', '^>^A', '>^^A'], A => ['v>A', '>vA']).Hash,
    3 => (0 => ['v<A', '<vA'], 1 => '<<A', 2 => '<A', 3 => 'A', 4 => ['<<^A', '^<<A', '<^<A'], 5 => ['^<A', '<^A'], 6 => '^A', 7 => ['^^<<A', '^<^<A', '<^^<A', '<<^^A', '^<<^A', '<^<^A'], 8 => ['^^<A', '^<^A', '<^^A'], 9 => '^^A', A => 'vA').Hash,
    4 => (0 => ['v>vA', '>vvA'], 1 => 'vA', 2 => ['v>A', '>vA'], 3 => ['>>vA', 'v>>A', '>v>A'], 4 => 'A', 5 => '>A', 6 => '>>A', 7 => '^A', 8 => ['^>A', '>^A'], 9 => ['>>^A', '^>>A', '>^>A'], A => ['v>v>A', '>vv>A', '>>vvA', 'v>>vA', '>v>vA']).Hash,
    5 => (0 => 'vvA', 1 => 'v<A', '<vA', 2 => 'vA', 3 => ['v>A', '>vA'], 4 => '<A', 5 => 'A', 6 => '>A', 7 => ['^<A', '<^A'], 8 => '^A', 9 => ['^>A', '>^A'], A => ['vv>A', 'v>vA', '>vvA']).Hash,
    6 => (0 => ['vv<A', 'v<vA', '<vvA'], 1 => ['<<vA', 'v<<A', '<v<A'], 2 => ['v<A', '<vA'], 3 => 'vA', 4 => '<<A', 5 => '<A', 6 => 'A', 7 => ['<<^A', '^<<A', '<^<A'], 8 => ['^<A', '<^A'], 9 => '^A', A => 'vvA').Hash,
    7 => (0 => ['vv>vA', 'v>vvA', '>vvvA'], 1 => 'vvA', 2 => ['vv>A', 'v>vA', '>vvA'], 3 => ['vv>>A', 'v>v>A', '>vv>A', '>>vvA', 'v>>vA', '>v>vA'], 4 => 'vA', 5 => ['v>A', '>vA'], 6 => ['>>vA', 'v>>A', '>v>A'], 7 => 'A', 8 => '>A', 9 => '>>A', A => ['vv>v>A', 'v>vv>A', '>vvv>A', 'vv>>vA', 'v>v>vA', '>vv>vA', '>>vvvA', 'v>>vvA', '>v>vvA']).Hash,
    8 => (0 => 'vvvA', 1 => ['vv<A', 'v<vA', '<vvA'], 2 => 'vvA', 3 => ['vv>A', 'v>vA', '>vvA'], 4 => ['v<A', '<vA'], 5 => 'vA', 6 => ['v>A', '>vA'], 7 => '<A', 8 => 'A', 9 => '>A', A => ['vvv>A', 'vv>vA', 'v>vvA', '>vvvA']).Hash,
    9 => (0 => ['vvv<A', 'vv<vA', 'v<vvA', '<vvvA'], 1 => ['vv<<A', 'v<v<A', '<vv<A', '<<vvA', 'v<<vA', '<v<vA'], 2 => ['vv<A', 'v<vA', '<vvA'], 3 => 'vvA', 4 => ['<<vA', 'v<<A', '<v<A'], 5 => ['v<A', '<vA'], 6 => 'vA', 7 => '<<A', 8 => '<A', 9 => 'A', A => 'vvvA').Hash,
    A => (0 => '<A', 1 => ['^<<A', '<^<A'], 2 => ['^<A', '<^A'], 3 => '^A', 4 => ['^<<^A', '<^<^A', '^^<<A', '^<^<A', '<^^<A'], 5 => ['^^<A', '^<^A', '<^^A'], 6 => '^^A', 7 => ['^^^<<A', '^^<^<A', '^<^^<A', '<^^^<A', '^<<^^A', '<^<^^A', '^^<<^A', '^<^<^A', '<^^<^A'], 8 => ['^^^<A', '^^<^A', '^<^^A', '<^^^A'], 9 => '^^^A', A => 'A').Hash,
;

my @dp-keys = <^ \> v \< A>;
my %dp2dp =
    '<' => ('<' => 'A', '>' => '>>A', A => ['>^>A', '>>^A'], '^' => '>^A', v => '>A').Hash,
    '>' => ('<' => '<<A', '>' => 'A', A => '^A', '^' => ['^<A', '<^A'], v => '<A').Hash,
    'A' => ('<' => ['v<<A', '<v<A'], '>' => 'vA', A => 'A', '^' => '<A', v => ['v<A', '<vA']).Hash,
    '^' => ('<' => 'v<A', '>' => ['v>A', '>vA'], A => '>A', '^' => 'A', v => 'vA').Hash,
    'v' => ('<' => '<A', '>' => '>A', A => ['^>A', '>^A'], '^' => '^A', v => 'A').Hash,
;

my @mem = ().Hash for ^26;
for @dp-keys X @dp-keys -> ($c1, $c2) {
    @mem[0]{$c1~$c2} = %dp2dp{$c1}{$c2}[0].chars;
}

my ($cnt-p1, $cnt-p2) X= 0;
for $f.IO.words -> $code {
    my @a = ([X] ['A', |$code.comb].rotor(2 => -1).map(-> ($c1, $c2) { %np2dp{$c1}{$c2} }))Â».join;
    $cnt-p1 += $code.substr(0, *-1) * @a.map({ solve($_, 2)  }).min;
    $cnt-p2 += $code.substr(0, *-1) * @a.map({ solve($_, 25) }).min;
}
put 'part 1: ', $cnt-p1;
put 'part 2: ', $cnt-p2;

sub dig(Str:D $c1, Str:D $c2, UInt:D $depth --> UInt:D) {
    my $key = $c1 ~ $c2;
    without @mem[$depth]{$key} {
        @mem[$depth]{$key} = %dp2dp{$c1}{$c2}.map(-> $seq {
            ('A' ~ $seq).comb.rotor(2 => -1).map(-> ($c1, $c2) { dig($c1, $c2, $depth - 1) }).sum
        }).min;
    }
    @mem[$depth]{$key}
}

sub solve(Str:D $seq, UInt:D $depth where * > 0 --> UInt:D) {
    ('A' ~ $seq).comb.rotor(2 => -1).map(-> ($c1, $c2) { dig($c1, $c2, $depth - 1) }).sum
}
